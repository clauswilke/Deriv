% Generated by roxygen2 (4.0.2): do not edit by hand
\name{Deriv}
\alias{Deriv}
\alias{derivatives}
\alias{simplifications}
\title{Symbollic differentiation of an expression or function}
\usage{
Deriv(f, x = if (length(find(deparse(substitute(f)))) && is.function(f))
  names(formals(f)) else
  stop("Argument 'f' is not a function, so variable name(s) must be supplied in 'x' argument"),
  env = if (is.function(f)) environment(f) else parent.frame())
}
\arguments{
\item{f}{An expression or function to be differentiated.
f can be \itemize{
 \item a user defined function \code{function(x) x**n}
 \item a string \code{"x**n"}
 \item an expression \code{expression(x**n)}
 \item a call \code{call("^", quote(x), quote(n))}
 \item a language \code{quote(x**n)}
 \item a right hand side of a formula \code{~ x**n} or \code{y ~ x**n}
}}

\item{x}{A character string with variable name(s) with resptect to which
\code{f} must be differentiated. If \code{f} is a function \code{x} is
optional and defaults to \code{names(formals(f))}}

\item{env}{An environment where the symbols and functions are searched for.
Defaults to \code{parent.frame()} for \code{f} expression and to
\code{environment(f)} if \code{f} is a function.}
}
\value{
\itemize{
 \item a function if \code{f} is a function
 \item an expression if \code{f} is an expression
 \item a language (usually a so called 'call' but may be also a symbol or just a numeric) for other types of \code{f}
}
}
\description{
Symbollic differentiation of an expression or function
}
\details{
R already contains two differentiation functions: D and deriv.  D does
simple univariate differentiation.  "deriv" uses D do to multivariate
differentiation.  The output of "D" is an expression, whereas the output of
"deriv" is an executable function.
R's existing functions have several limitations.  They can probably be fixed,
but since they are written in C, this would probably require a lot of work.
Limitations include:
\itemize{
 \item The derivatives table can't be modified at runtime, and is only available
in C.
 \item The output of "deriv" can not be differentiated again.
 \item Neither function can substitute function calls.  eg:
	f <- function(x, y) x + y; deriv(f(x, x^2), "x")
}

So, here are the advantages and disadvantages of this implementation:
GOOD POINTS:
\itemize{
 \item It is entirely written in R, so would be easier to maintain.
 \item Can do multi-variate differentiation.
 \item Can differentiate function calls:
 \item It's easy to add custom entries to the derivatives table.  It could be
easier though... it would be nice if something like
worked, rather than the clunky function definitions.  (This is purely a
cosmetic issue, though... everything works as is.)
 \item The output is an executable function, which makes it suitable for use in
optimization problems.
}

BAD POINTS:
\itemize{
 \item Differentiating vector-valued functions doesn't work properly, since
the multiplication code doesn't know when to use scalar vs matrix
multiplication.  Unfortunately, solving this is a hard problem because
we would need to know if an arbitrary expression is a vector or not.
We would have to add extra metadata to do this.  Bottom line: can compute
gradients but not Jacobians or Hessians.
 \item Gives useless error messages when it gets stuck.  This could be fixed.
}
Two working environments derivatives and simplifications are created in the package
namescape. As their names indicates, they contain tables of derivatives and
simplification rules. A priori, user does not had to manipulate them directly.
}
\examples{
\dontrun{f <- function(x) x^2}
\dontrun{Deriv(f)}
# function (x)
# 2 * x

\dontrun{f <- function(x, y) sin(x) * cos(y)}
\dontrun{Deriv(f)}
# function (x, y)
# sin(x) * -sin(y) * t(c(0, 1)) + cos(x) * t(c(1, 0)) *  cos(y)

\dontrun{f_ <- Deriv(f)}
\dontrun{f_(3, 4)}
#              x         y
# [1,] 0.6471023 0.1068
\dontrun{Deriv(~ f(x, y^2)), "y")}
# 2 * (sin(x) * -sin(y^2) * y)

\dontrun{Deriv(quote(f(x, y^2)), c("x", "y"))}
# 2 * (sin(x) * -sin(y^2) * y * t(c(0, 1))) + cos(x) *
#     t(c(1, 0)) * cos(y^2))

\dontrun{Deriv(expression(sin(x^2) * y), "x")}
# expression(cos(x^2) * (2 * x) * y)
}
\concept{
symbollic derivation
}

